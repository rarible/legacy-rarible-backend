archetype exchange(
  owner             : address,
  transferManager   : address,
  royaltiesContract : address,
  fill              : address)
with metadata ""

variable owner_candidate : option<address> = none

entry declareOwnership(candidate : address) {
  called by owner
  effect {
    owner_candidate := some(candidate);
  }
}

entry claimOwnership() {
  called by opt_get(owner_candidate)
  effect {
    owner := opt_get(owner_candidate);
    owner_candidate := none
  }
}

entry setTransferManager(newTransferManager : address) {
  called by owner
  effect { transferManager := newTransferManager }
}

entry setRoyaltiesContract(iroyalties_contract : address) {
  called by owner
  effect {
    royaltiesContract := iroyalties_contract
  }
}

enum fa2_class =
| Fungible
| NonFungible
| Unknown

enum asset_class =
| XTZ
| FA_1_2
| FA_2<fa2_class>
| FA_2_LAZY<fa2_class>
| OTHER<bytes>

record asset_type {
  assetClass : asset_class;
  assetData : bytes;
}

record %asset {
  assetType : asset_type;
  assetValue : nat;
}

record order {
  maker : option<key>;
  makeAsset : %asset;
  taker : option<key>;
  takeAsset : %asset;
  salt : nat;
  start : option<date>;
  %end :  option<date>;
  dataType : bytes;
  data : bytes;
}

record fill_result {
  fr_makeValue : nat;
  fr_takeValue : nat;
}

enum fee_side =
| NONE
| MAKE
| TAKE

record part {
  partAccount : address;
  partValue   : nat;
}

constant V1 : bytes = keccak(pack("V1"))
constant V2 : bytes = keccak(pack("V2"))

record DataV1 {
  v1_payouts : list<part>;
  v1_originFees : list<part>;
}

record DataV2 {
  v2_payouts : list<part>;
  v2_originFees : list<part>;
  v2_isMakeFill : bool
}

entry setMetadataUri(idata : bytes) {
  called by owner
  effect {
    metadata := put(metadata, "", idata)
  }
}

entry setFill(f : address) {
  called by owner
  effect {
    fill := f
  }
}

entry cancel(iorder : order) {
  called by owner or key_address(opt_get(iorder.maker))
  require {
    r1: iorder.salt <> 0 otherwise "0 salt can't be used";
  }
  effect {
    transfer 0tz to fill call remove<bytes>(hashKeyOrder(iorder))
  }
}

// who fills asset collection `fill` ?
function hashKeyOrder(iorder : order) : bytes {
  if (iorder.dataType = V2) then
    return keccak(concat([
      pack(iorder.maker);
      keccak(pack(iorder.makeAsset.assetType));
      keccak(pack(iorder.takeAsset.assetType));
      pack(iorder.salt);
      pack(iorder.data)])
    )
  else return keccak(concat([
    pack(iorder.maker);
    keccak(pack(iorder.makeAsset.assetType));
    keccak(pack(iorder.takeAsset.assetType));
    pack(iorder.salt)]))
}

function safeGetPartialAmountFloor(
    numerator: nat,
    denominator: nat,
    target: nat) : nat {
  var num = numerator * target;
  match num /% denominator with
  | some(p) -> begin
    if (num <> 0) then dofailif (p[1] * 1_000 >= num, "rounding error");
    return p[0]
    end
  | none -> fail("division by zero")
  end
}

function calculateRemaining(iorder : order, ifill : nat, isMakeFill : bool) : (nat * nat) {
  if not isMakeFill then begin
    if (iorder.takeAsset.assetValue < ifill) then (
      fail(("calculateRemaining", iorder.takeAsset.assetValue, ifill))
    );
    var takeValue = sub_nat(iorder.takeAsset.assetValue, ifill);
    var makeValue = safeGetPartialAmountFloor(iorder.makeAsset.assetValue, iorder.takeAsset.assetValue, takeValue);
    return ((makeValue, takeValue))
  end else begin
    if (iorder.makeAsset.assetValue < ifill) then (
      fail(("calculateRemaining", iorder.makeAsset.assetValue, ifill))
    );
    var makeValue = sub_nat(iorder.makeAsset.assetValue, ifill);
    var takeValue = safeGetPartialAmountFloor(iorder.takeAsset.assetValue, iorder.makeAsset.assetValue, makeValue);
    return ((makeValue, takeValue))
  end
}

function fillLeft(leftMakeValue : nat, leftTakeValue : nat, rightMakeValue : nat, rightTakeValue : nat) : fill_result {
  var rightTake = safeGetPartialAmountFloor(leftTakeValue, rightMakeValue, rightTakeValue);
  dorequire(rightTake <= leftMakeValue, "fillLeft: unable to fill");
  return ({leftMakeValue; leftTakeValue})
}

function fillRight(leftMakeValue : nat, leftTakeValue : nat, rightMakeValue : nat, rightTakeValue : nat) : fill_result {
  var makerValue = safeGetPartialAmountFloor(rightTakeValue, leftMakeValue, leftTakeValue);
  dorequire(makerValue <= rightMakeValue, "fillRight: unable to fill");
  return ({rightTakeValue; makerValue})
}

function fillOrder(leftOrder : order, rightOrder : order, leftOrderFill : nat, rightOrderFill : nat, leftIsMakeFill : bool, rightIsMakeFill : bool) : fill_result {
  var leftPair  = calculateRemaining(leftOrder, leftOrderFill, leftIsMakeFill);
  var rightPair = calculateRemaining(rightOrder, rightOrderFill, rightIsMakeFill);

  var leftMakeValue  = leftPair[0];
  var leftTakeValue  = leftPair[1];
  var rightMakeValue = rightPair[0];
  var rightTakeValue = rightPair[1];

  return
  (if (rightTakeValue > leftMakeValue)
  then fillLeft(leftMakeValue, leftTakeValue, rightOrder.makeAsset.assetValue, rightOrder.takeAsset.assetValue)
  else fillRight(leftOrder.makeAsset.assetValue, leftOrder.takeAsset.assetValue, rightMakeValue, rightTakeValue))
}

function getOrderFill(iorder : order, ihash : bytes) : nat {
  var res : nat = 0;
  var fillcontains = match callview<bool>(fill, "contains", ihash) with | some(v) -> v | none -> false end;
  if (iorder.salt <> 0 and fillcontains) then
    match callview<option<nat>>(fill, "get", ihash) with
      | some(optv) ->
        match optv with
        | some(v) -> res := v
        | none -> fail("order canceled")
        end
      | none -> fail("invalid fill")
    end;
  return res
}

function getFeeSide(imake : asset_class, itake : asset_class) : fee_side {
  if imake = XTZ
  then return MAKE
  else if itake = XTZ
  then return TAKE
  else if imake = FA_1_2
  then return MAKE
  else if itake = FA_1_2
  then return TAKE
  else if imake = FA_2(Fungible)
  then return MAKE
  else if itake = FA_2(Fungible)
  then return TAKE
  else return NONE
}

record MintFA2Data {
  mfd_tokenId : nat;
  mfd_tokenURI : string;
  mfd_supply : nat;
  mfd_creators : list<part>;
  mfd_royalties : list<part>;
  mfd_signatures : list<bytes>;
}

function getRoyaltiesByAssetType(matchNft : asset_type, idata : bytes, s : address) : list<part> {
  var empty_royalties : list<part> = [];
  var res = empty_royalties;

  match matchNft.assetClass with
  | FA_2_LAZY(fa2t) -> begin
    match unpack<address * MintFA2Data>(matchNft.assetData) with
    | some (v) -> res := v[1].mfd_royalties
    | none -> fail (("cannot unpack FA_2_LAZY", matchNft.assetData))
    end
  end
  | FA_2(fa2t) -> begin
    match unpack<address * nat>(matchNft.assetData) with
    | some (v) ->
      var token : address = v[0];
      var tokenId : nat   = v[1];
      match callview<list<part>>(royaltiesContract, "get_royalties", (token,tokenId)) with
      | some(roy) -> res := roy
      | none -> fail("cannot get royalies from contract")
      end
    | none -> fail (("cannot unpack FA_2", matchNft.assetData))
    end
  end
  | _ -> ()
  end;

  return res
}

function getFillSetNew(
  orderLeft         : order,
  orderRight        : order,
  leftOrderKeyHash  : bytes,
  rightOrderKeyHash : bytes,
  leftOrderData     : DataV2,
  rightOrderData    : DataV2) : (fill_result * option<nat> * option<nat>) {
  var leftOrderFill = getOrderFill(orderLeft, leftOrderKeyHash);
  var rightOrderFill = getOrderFill(orderRight, rightOrderKeyHash);
  var newFill = fillOrder(orderLeft, orderRight, leftOrderFill, rightOrderFill, leftOrderData.v2_isMakeFill, rightOrderData.v2_isMakeFill);
  dorequire(newFill.fr_takeValue > 0 and newFill.fr_makeValue > 0, "nothing to fill");
  var leftOrderNewFill : option<nat> = none;
  if (orderLeft.salt <> 0) then
    if leftOrderData.v2_isMakeFill then
      leftOrderNewFill := some((leftOrderFill + newFill.fr_makeValue))
    else
      leftOrderNewFill := some((leftOrderFill + newFill.fr_takeValue));

  var rightOrderNewFill : option<nat> = none;
  if (orderRight.salt <> 0) then
    if rightOrderData.v2_isMakeFill then
      rightOrderNewFill := some((rightOrderFill + newFill.fr_takeValue))
    else
      rightOrderNewFill := some((rightOrderFill + newFill.fr_makeValue));

  return ((newFill, leftOrderNewFill, rightOrderNewFill))
}

function payoutSet(orderAddress : address, dataOrderOnePayoutIn : DataV2) : DataV2 {
  return { dataOrderOnePayoutIn with v2_payouts = [{ partAccount = orderAddress; partValue = 10000 }] }
}

function parse(iorder : order) : DataV2 {
  var addr_maker : address = key_address(opt_get(iorder.maker));
  if (iorder.dataType = V1) then (
    match unpack<DataV1>(iorder.data) with
    | some(dataOrder) -> begin
      var res : DataV2 = {
        dataOrder.v1_payouts;
        dataOrder.v1_originFees;
        false
       };
       if (length(dataOrder.v1_payouts) = 0) then (
         res := payoutSet(addr_maker, res);
       );
      return res
    end
    | none -> fail("unable to unpack DataV1")
    end
  ) else if (iorder.dataType = V2) then (
    match unpack<DataV2>(iorder.data) with
    | some(dataOrder) -> begin
      var res = dataOrder;
      if (length(dataOrder.v2_payouts) = 0) then (
        res := payoutSet(addr_maker, dataOrder);
      );
      return res
    end
    | none -> fail("unable to unpack DataV2")
    end
  ) else if (iorder.dataType = 0xffffffff) then (
    var res : DataV2 = { []; []; false };
    return payoutSet(addr_maker, res)
  ) else (
    fail("Unknown Order data type")
  )
}

entry matchAndTransfer(orderLeft : order, orderRight : order, imakeMatch : option<asset_type>, itakeMatch : option<asset_type>) {
  called by selfaddress
  effect {
    var makeMatch = require_some(imakeMatch, "Invalid makeMatch");
    var takeMatch = require_some(itakeMatch, "Invalid takeMatch");
    var leftOrderKeyHash  = hashKeyOrder(orderLeft);
    var rightOrderKeyHash = hashKeyOrder(orderRight);
    var leftOrderData     = parse(orderLeft);
    var rightOrderData    = parse(orderRight);

    var getFillSetNewRes  = getFillSetNew(orderLeft, orderRight, leftOrderKeyHash, rightOrderKeyHash, leftOrderData, rightOrderData);
    var newFill           = getFillSetNewRes[0];
    var leftOrderNewFill  = getFillSetNewRes[1];
    var rightOrderNewFill = getFillSetNewRes[2];

    match leftOrderNewFill with
    | some(v) -> transfer 0tz to fill call put<bytes * nat>((leftOrderKeyHash, v))
    | none -> ()
    end;
    match rightOrderNewFill with
    | some(v) -> transfer 0tz to fill call put<bytes * nat>((rightOrderKeyHash, v))
    | none -> ()
    end;

    var feeSide = getFeeSide(makeMatch.assetClass, takeMatch.assetClass);
    var packedData = pack((makeMatch, takeMatch, newFill, orderLeft, orderRight, feeSide));
    var empty_royalties : list<part> = [];
    var royalties : list<part> =
      match feeSide with
      | MAKE -> getRoyaltiesByAssetType(takeMatch, packedData, selfaddress)
      | TAKE -> getRoyaltiesByAssetType(makeMatch, packedData, selfaddress)
      | NONE -> empty_royalties
      end;

    var leftOrderMaker  : address = key_address(opt_get(orderLeft.maker));
    var rightOrderMaker : address = key_address(opt_get(orderRight.maker));

    transfer transferred to transferManager call doTransfers<asset_type * asset_type * DataV2 * DataV2 * fill_result * address * address * fee_side * list<part>>
    ((makeMatch, takeMatch, leftOrderData, rightOrderData, newFill, leftOrderMaker, rightOrderMaker, feeSide, royalties))
  }
}

enum time_pos = | PAST | FUTURE

function validateDate(d : option<date>, pos : time_pos) : bool {
  return
    match d with
      | some(v) ->
        match pos with
        | PAST   -> v < now
        | FUTURE -> v > now
        end
      | none -> true
    end
}

function validate (iorder : order, isig : option<signature>) : bool {
  var key_maker : key = opt_get(iorder.maker);
  var addr_maker : address = key_address(key_maker);
  if (iorder.salt = 0) then (
    dorequire(source = addr_maker, "maker is not tx sender");
    return true
  ) else (
    if (source <> addr_maker) then (
      var s = require_some(isig, "signature none");
      return check_signature(key_maker, s, pack(iorder))
    ) else (
      return true
    )
  )
}

function is_caller(k : option<key>) : bool {
  match k with
    | some(k) -> return (key_address(k) = caller)
    | none -> return false
  end
}

function validateFull(iorder : order, isignature : option<signature>) : bool {
  dorequire(validateDate(iorder.start, PAST), "Order start validation failed");
  dorequire(validateDate(iorder.%end, FUTURE), "Order end validation failed");
  dorequire(validate(iorder, isignature), ("Bad signature", opt_get(iorder.maker), pack(iorder), isignature));
  return true
}


function simpleMatch(leftAssetType : asset_type, rightAssetType : asset_type) : option<asset_type> {
  var leftHash  = keccak(leftAssetType.assetData);
  var rightHash = keccak(rightAssetType.assetData);
  if (leftHash = rightHash)
  then return some(leftAssetType)
  else return none<asset_type>
}

function isOther(iassetClass : asset_class) : bool {
  return
    match iassetClass with
    | OTHER(v) -> true
    | _ -> false
    end
}

function eqOther(iLeftClass : asset_class, iRightClass : asset_class) : bool {
  return (isOther(iLeftClass) and isOther(iRightClass) and
    match iLeftClass with
    | OTHER(v) -> some(v)
    | _ -> none<bytes>
    end
    =
    match iRightClass with
    | OTHER(v) -> some(v)
    | _ -> none<bytes>
    end
  )
}

// matchAssetOneSide
function matchAssetTypes(leftAssetType : asset_type, rightAssetType : asset_type) : option<asset_type> {
  var classLeft = leftAssetType.assetClass;
  var classRight = rightAssetType.assetClass;
  var classPair = (classLeft, classRight);

  if (classPair = (XTZ, XTZ))
  then return some(leftAssetType)
  else if
    classPair = (FA_1_2, FA_1_2) or
    classPair = (FA_2(Fungible), FA_2(Fungible)) or
    classPair = (FA_2(NonFungible), FA_2(NonFungible)) or
    eqOther(classLeft, classRight)
  then return simpleMatch(leftAssetType, rightAssetType)
  else return none<asset_type>
}

entry matchOrders(
  orderLeft : order,
  signatureLeft : option<signature>,
  orderRight : order,
  signatureRight : option<signature>) {
  var a_ = validateFull(orderLeft, signatureLeft);
  var b_ = validateFull(orderRight, signatureRight);
  if (issome(orderLeft.taker))
  then dorequire(orderRight.maker = orderLeft.taker, "leftOrder.taker verification failed");
  if (issome(orderRight.taker))
  then dorequire(orderRight.taker = orderLeft.maker, "rightOrder.taker verification failed");

  var makeMatch = matchAssetTypes(orderLeft.makeAsset.assetType, orderRight.takeAsset.assetType);
  var takeMatch = matchAssetTypes(orderLeft.takeAsset.assetType, orderRight.makeAsset.assetType);
  transfer transferred to entry self.matchAndTransfer(orderLeft, orderRight, makeMatch, takeMatch)
}
